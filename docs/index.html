<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>Cemu Graphic Packs</title>
	<link rel="stylesheet" type="text/css" href="css/index.css">
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<!-- >>> Javascript functions <<< -->
	<script>
		// Calculate Github repository info, avoid using extra api calls.
		repositoryUsername = "Crementif"; // Replace with window.location.host.split(".")[0];
		repositoryName = "CemuGraphicPacks"; // Replace with window.location.pathname.split("/")[1];
		defaultFetchUrl = "https://api.github.com/repos/"+repositoryUsername+"/"+repositoryName+"/git/trees/master:src?recursive=3";
		defaultFileUrl = "https://raw.githubusercontent.com/"+repositoryUsername+"/"+repositoryName+"/master/src/"
		// This info is only used to make 'dynamic' fetch calls.
		
		var gameList = {};
		function textureRule(sectionName) {
    		this.sectionName = sectionName;
			// Filters
   			this.width = null;
    		this.height = null;
    		this.formats = null;
			this.formatsExcluded = null;
			this.tilemodes = null;
			this.tilemodesExcluded = null;
			// Overwrites
			this.overwriteWidth = [undefined, 0, 0];
			this.overwriteHeight = [undefined, 0, 0];
			this.overwriteFormat = [undefined, 0, 0];
		}
		
		function addGameList(folderName, gameTitle) { // Use template to add a new game entry to the list. The passed variables will change the result.
			gameListTemplate = document.querySelector('#gameListTemplate');
			gameListTemplate.content.querySelector('input').id=folderName;
			gameListTemplate.content.querySelector('label').htmlFor=folderName;
			gameListTemplate.content.querySelector('label').innerText=gameTitle[0]; // The first search tag should always be the game name.
			gameListTemplate.content.querySelector('div').dataset.searchtags=JSON.stringify(gameTitle); // Store all the tags in an attribute.
			
			document.getElementsByName("selectGames")[0].appendChild(document.importNode(gameListTemplate.content, true));
		}
		
		function filterGameList(searchString) {
			gameNodes = document.getElementsByClassName("gameList");
			searchResults = 0;
			for (i=0; i<gameNodes.length; i++) { // Cycle through all of the games
				for (j=0; j<JSON.parse(gameNodes[i].dataset.searchtags).length; j++) { // Cycle trough each of the search tags
					if (JSON.parse(gameNodes[i].dataset.searchtags)[j].toUpperCase().indexOf(searchString.value.toUpperCase()) > -1) {
						gameNodes[i].style.display = ""; // Found matching search tag.
						searchResults += 1;
						break; // Break and continue to check for other games.
					}
					else {
						gameNodes[i].style.display = "none"; // Hide game from the list, but it next search tag might reveal it.
					}
				}
			}
			console.log("Received "+searchResults+" search results.");
		}
		
		function showLoad() {
			for (var game in gameList) {
				addGameList(game, gameList[game].searchTags);
				// console.log(gameList[game]);
			}
		}
		
		function filterUndefined(array) {
			newArray = [];
			for (i=0; i < array.length; i++) {
    			if (array[i] !== undefined) newArray.push(array[i]);
  			}
			return newArray;
		}
		
		function fetchUrl(url, options) {
			return fetch(url, options).then(function(fetchResponse) {
				if (!fetchResponse.ok) {
					throw Error("A wild fetch problem appeared! It's super effective! It's Fetch Status Codeâ„¢ is "+fetchResponse.statusText);
				}
				return fetchResponse;
			})
		}
		
		function fetchJson(jsonUrl) { // Async, returns Promise.
			return fetchUrl(jsonUrl, {cache: "force-cache", headers: {Accept: "application/vnd.github.v3+json"}}).then(jsonResponse => jsonResponse.json());
		}
		
		function fetchText(textUrl) {
			return fetchUrl(defaultFileUrl+textUrl, {cache: "no-store"}).then(textResponse => textResponse.text());
		}
		
		function listResponses(treeEntry) {
			// Process every entry passed into gameList.
			if (treeEntry.path.split("/").length - 1 == 0) { // 
				// Found game folder, add game's array to gameList.
				gameList[treeEntry.path] = {}; // Creates gameList abbtribute for this game.
				currentGame = treeEntry.path; // This allows `this` to access this game's attribute.
			}
			else if (treeEntry.path == treeEntry.path.split("/")[0]+"/rules.txt") {
				// Found main resolution pack, crawl (meta)data info.
				return fetchText(treeEntry.path).then(rulesResponse => {
					// Define some functions only used for rules.txt's.
					function getKeyProperties(keyString) {
						// Split name and value (and trim them). Returns an array, key name[0] and key value[1].
						return keyString.split(/=(.+)/).map(array => array.trim());
					}
					function processGameRule(textureRule) {
						// Save instructions to this file's entry in the game folder.
						if (textureRule.overwriteWidth[0]=="auto") {
							gameList[currentGame][treeEntry.path].push([textureRule.width, textureRule.overwriteWidth[1], textureRule.overwriteWidth[2]]);
						}
						if (textureRule.overwriteHeight[0]=="auto") {
							gameList[currentGame][treeEntry.path].push([textureRule.height, textureRule.overwriteWidth[1], textureRule.overwriteWidth[2]]);
						}
						if (textureRule.overwriteFormat[0]=="unimplemented") {
							// Implement overwriteFormat features too depending if it's necessairy in any way...
						}
					}
					
					rulesLines = rulesResponse.match(/[^\r\n]+/g);
					currentGame = treeEntry.path.split("/")[0];
					currentRule = new textureRule(undefined);
					gameList[currentGame][treeEntry.path] = [];
					indexLength = 0;
					
					for (i=0; i<rulesLines.length; i++) {
						// Keeping comments, but have something to compare with. Also make a variable that holds the current line, as it'll result in overall faster read access.
						currentLine = rulesLines[i].trim();
						parseLine = currentLine.substr(0, -currentLine.indexOf("#")>0 ? currentLine.length : currentLine.indexOf("#")).trim();
						
						if (currentLine !== "") {
							if (parseLine.charAt(0) == '[' && parseLine.slice(-1) == ']') { // New section
								// First, process the textureRule before creating a new textureRule.
								if (currentRule.sectionName!=undefined) processGameRule(currentRule);
								currentRule = new textureRule(parseLine);
							}
							else if (currentRule.sectionName=="[Definition]") {
								// Generally, we only expect metadata in "[Definition]" section for rules.
								if (currentLine.charAt(0) == '#' && currentLine.charAt(1) == '#') { // Current line
									gameList[currentGame][getKeyProperties(currentLine.substr(2))[0]] = JSON.parse(getKeyProperties(currentLine.substr(2))[1]);
								}
								// Now only expect either a name or titleId's keys.
								else if (getKeyProperties(parseLine)[0]=="name") { // Game Title
									gameList[currentGame].gameTitle = getKeyProperties(parseLine)[1].slice(1, -1); // Removes quotes.
								}
								else if (getKeyProperties(parseLine)[0]=="titleIds") { // Game IDs
									gameList[currentGame].titleIds = getKeyProperties(parseLine)[1];
								}
								else {
									console.warn("Unexpected rules line: `"+parseLine+"` in `"+currentRule.sectionName+"` section from `"+treeEntry.path+"`.");
								}
							}
							else if (currentRule.sectionName=="[TextureRedefine]") {
								// First, read the filters.
								if (getKeyProperties(parseLine)[0]=="width") {
									currentRule.width = getKeyProperties(parseLine)[1];
								}
								else if (getKeyProperties(parseLine)[0]=="height") {
									currentRule.height = getKeyProperties(parseLine)[1];
								}
								else if (getKeyProperties(parseLine)[0]=="formats") {
									currentRule.formats = getKeyProperties(parseLine)[1];
								}
								else if (getKeyProperties(parseLine)[0]=="formatsExcluded") {
									currentRule.formatsExcluded = getKeyProperties(parseLine)[1];
								}
								else if (getKeyProperties(parseLine)[0]=="tilemodes") {
									currentRule.tilemodes = getKeyProperties(parseLine)[1];
								}
								else if (getKeyProperties(parseLine)[0]=="tilemodesExcluded") {
									currentRule.tilemodesExcluded = getKeyProperties(parseLine)[1];
								}
								// Read overwrites into this format [value, index]
								else if (getKeyProperties(parseLine)[0]=="overwriteWidth") {
									currentRule.overwriteWidth = [getKeyProperties(parseLine)[1],indexLength+rulesLines[i].indexOf(getKeyProperties(parseLine)[1]), getKeyProperties(parseLine)[1].length];
								}
								else if (getKeyProperties(parseLine)[0]=="overwriteHeight") {
									currentRule.overwriteHeight = [getKeyProperties(parseLine)[1],indexLength+rulesLines[i].indexOf(getKeyProperties(parseLine)[1]), getKeyProperties(parseLine)[1].length];
								}
								else if (getKeyProperties(parseLine)[0]=="overwriteFormat") {
									currentRule.overwriteFormat = [getKeyProperties(parseLine)[1],indexLength+rulesLines[i].indexOf(getKeyProperties(parseLine)[1]), getKeyProperties(parseLine)[1].length];
								}
							}
						}
						indexLength += rulesLines[i].length;
					}
					gameList[currentGame].searchTags.unshift(gameList[currentGame].gameTitle); // Add game title to search tags, easier to pass.
					
					return rulesResponse;
				});
			}
		}
		
		function listGames(treeFetchUrl) { // Fetch repository contents
			if (self.fetch) {
				// Fetch is supported by browser.
				fetchJson(treeFetchUrl).then(treeResponse => {
					// Initialize new Promise, made out of every other game file.
					Promise.all(filterUndefined(treeResponse.tree.map(listResponses/*For every entry in the fetched github json*/))).then(dataResponses => {
						// Now that all promises are resolved (and everything is in gameList), wait for user interaction to finish.
						showLoad();
						console.log("All promises are resolved, succesfully loaded "+dataResponses.length+" responses!");
					});
				});
			}
			else {
				console.warn("Fetch isn't supported (yet) for your browser. If you get this error, your browser isn't yet supported by this website.");
			}
		}
		listGames(defaultFetchUrl);
	</script>
	<!-- <<< End Javascript >>> -->
</head>
<body>
	<header>
		<a id="logo" href="/index.html">Cemu Graphic Packs</a>
		<nav>
			<ul class="progressBar">
				<li><a id="progressBar1" href="#">Download Graphic Packs</a></li>
				<li><a id="progressBar2" href="#">Select additional packs</a></li>
			</ul>
		</nav>
	</header>
	
	<main>
		<form name="selectGames" enctype="text/plain">
			<p>Select a few of these graphic packs!<br></p>
			<input type="search" id="searchGames" placeholder="Search games..." oninput="filterGameList(this)">
			
			<template id="gameListTemplate">
				<div class="gameList" data-searchtags="arraySearchTags">
					<input type="checkbox" id="folderName" name="game">
					<label for="folderName">gameTitle</label>
				</div>
			</template>
			
			<script>
			</script>
		</form>
	</main>
	
	<footer>
		<div id="cookieWarn">
			This site uses cookies for features (e.g. remembering previous downloaded packs to show updates). It doesn't get shared, but thought you'd like a warning. It's your computer after all. You can always change this in the settings.
			<span>
				<strong>Sure</strong><strong>Nope</strong>
			</span>
		</div>
  		<strong class="hidden">Settings</strong>
		<span class="hidden">
			<a href="">Help us over on github!</a>
			<a href="">Site not working?</a>
			<a href="">Graphic packs for Cemu&lt;1.8.0</a>
		</span>
	</footer>
</body>
</html>
