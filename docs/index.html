<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>Cemu Graphic Packs</title>
	<link rel="stylesheet" type="text/css" href="css/index.css">
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<!-- >>> Javascript functions <<< -->
	<script>
		// Calculate Github repository info, avoid using extra api calls.
		repositoryUsername = "Crementif"; // Replace with window.location.host.split(".")[0];
		repositoryName = "CemuGraphicPacks"; // Replace with window.location.pathname.split("/")[1];
		defaultFetchUrl = "https://api.github.com/repos/"+repositoryUsername+"/"+repositoryName+"/git/trees/master:src?recursive=3";
		defaultFileUrl = "https://raw.githubusercontent.com/"+repositoryUsername+"/"+repositoryName+"/master/src/"
		// This info is only used to make 'dynamic' fetch calls.
		
		var gameList = {};
		
		function addGameList(folderName, gameTitle) { // Use template to add a new game entry to the list. The passed variables will change the result.
			gameListTemplate = document.querySelector('#gameListTemplate');
			gameListTemplate.content.querySelector('input').id=folderName;
			gameListTemplate.content.querySelector('label').htmlFor=folderName;
			gameListTemplate.content.querySelector('label').innerText=gameTitle[0]; // The first search tag should always be the game name.
			gameListTemplate.content.querySelector('div').dataset.searchtags=JSON.stringify(gameTitle); // Store all the tags in an attribute.
			
			document.getElementsByName("selectGames")[0].appendChild(document.importNode(gameListTemplate.content, true));
		}
		
		function filterGameList(searchString) {
			gameNodes = document.getElementsByClassName("gameList");
			searchResults = 0;
			for (i=0; i<gameNodes.length; i++) { // Cycle through all of the games
				for (j=0; j<JSON.parse(gameNodes[i].dataset.searchtags).length; j++) { // Cycle trough each of the search tags
					if (JSON.parse(gameNodes[i].dataset.searchtags)[j].toUpperCase().indexOf(searchString.value.toUpperCase()) > -1) {
						gameNodes[i].style.display = ""; // Found matching search tag.
						searchResults += 1;
						break; // Break and continue to check for other games.
					}
					else {
						gameNodes[i].style.display = "none"; // Hide game from the list, but it next search tag might reveal it.
					}
				}
			}
			console.log("Received "+searchResults+" search results.");
		}
		
		function showLoad() {
			for (var game in gameList) {
				addGameList(game, gameList[game].searchTags);
				// console.log(gameList[game]);
			}
		}
		
		function filterUndefined(array) {
			newArray = [];
			for (i=0; i < array.length; i++) {
    			if (array[i] !== undefined) newArray.push(array[i]);
  			}
			return newArray;
		}
		
		function fetchUrl(url, options) {
			return fetch(url, options).then(function(fetchResponse) {
				if (!fetchResponse.ok) {
					throw Error("A wild fetch problem appeared! It's super effective! It's Fetch Status Codeâ„¢ is "+fetchResponse.statusText);
				}
				return fetchResponse;
			})
		}
		
		function fetchJson(jsonUrl) { // Async, returns Promise.
			return fetchUrl(jsonUrl, {cache: "force-cache", headers: {Accept: "application/vnd.github.v3+json"}}).then(jsonResponse => jsonResponse.json());
		}
		
		function fetchText(textUrl) {
			return fetchUrl(defaultFileUrl+textUrl, {cache: "no-store"}).then(textResponse => textResponse.text());
		}
		
		function listResponses(treeEntry) {
			// Process every entry passed into gameList.
			if (treeEntry.path.split("/").length - 1 == 0) { // 
				// Found game folder, add game's array to gameList.
				gameList[treeEntry.path] = {}; // Creates gameList abbtribute for this game.
				currentGame = treeEntry.path; // This allows `this` to access this game's attribute.
			}
			else if (treeEntry.path == treeEntry.path.split("/")[0]+"/rules.txt") {
				// Found main resolution pack, crawl (meta)data info.
				return fetchText(treeEntry.path).then(rulesResponse => {
					// Define some functions only used for rules.txt's.
					function getKeyProperties(keyString) {
						// Split name and value (and trim them). Returns an array, name[0] and value[1].
						return keyString.split(/=(.+)/).map(array => array.trim());
					}
					
					rulesLines = rulesResponse.match(/[^\r\n]+/g);
					currentGame = treeEntry.path.split("/")[0];
					for (i=0; i<rulesLines.length; i++) {
						// Keeping comments, but have something to compare with. Also make a variable that holds the current line, as it'll result in overall faster read access.
						currentLine = rulesLines[i].trim();
						parseLine = currentLine.substr(0, -currentLine.indexOf("#")>0 ? currentLine.length : currentLine.indexOf("#")).trim();
						
						if (parseLine.charAt(0) == '[' && parseLine.slice(-1) == ']') { // New section
							currentSection = parseLine;
						}
						else if (currentSection=="[Definition]") {
							// Generally, we only expect metadata in "[Definition]" section for rules.
							if (currentLine.charAt(0) == '#' && currentLine.charAt(1) == '#') { // Current line
								gameList[currentGame][getKeyProperties(currentLine.substr(2))[0]] = JSON.parse(getKeyProperties(currentLine.substr(2))[1]);
							}
							// Now only expect either a name or titleId's keys.
							else if (getKeyProperties(parseLine)[0]=="name") { // Game Title
								gameList[currentGame].gameTitle = getKeyProperties(parseLine)[1].slice(1, -1); // Removes quotes.
							}
							else if (getKeyProperties(parseLine)[0]=="titleIds") { // Game IDs
								gameList[currentGame].titleIds = getKeyProperties(parseLine)[1];
							}
							else {
								console.warn("Unexpected rules line: `"+parseLine+"` in `"+currentSection+"` section from `"+treeEntry.path+"`.");
							}
							
						}
						// Write temporary placeholders, place 'instructions' 
					}
					gameList[currentGame].searchTags.unshift(gameList[currentGame].gameTitle); // Add game title to search tags, easier to pass.
					
					return rulesResponse;
				});
			}
		}
		
		function listGames(treeFetchUrl) { // Fetch repository contents
			if (self.fetch) {
				// Fetch is supported by browser.
				fetchJson(treeFetchUrl).then(treeResponse => {
					console.debug(treeResponse);
					// Initialize new Promise, made out of every other game file.
					Promise.all(filterUndefined(treeResponse.tree.map(listResponses))).then(dataResponses => {
						// Now that all promises are resolved (and everything is in gameList), wait for user interaction to finish.
						showLoad();
					});
				});
			}
			else {
				console.warn("Fetch isn't supported (yet) for your browser. If you get this error, your browser isn't yet supported by this website.");
			}
		}
		listGames(defaultFetchUrl);
	</script>
	<!-- <<< End Javascript >>> -->
</head>
<body>
	<header>
		<a id="logo" href="/index.html">Cemu Graphic Packs</a>
		<nav>
			<ul class="progressBar">
				<li><a id="progressBar1" href="#">Download Graphic Packs</a></li>
				<li><a id="progressBar2" href="#">Select additional packs</a></li>
			</ul>
		</nav>
	</header>
	
	<main>
		<form name="selectGames" enctype="text/plain">
			<p>Select a few of these graphic packs!<br></p>
			<input type="search" id="searchGames" placeholder="Search games..." oninput="filterGameList(this)">
			
			<template id="gameListTemplate">
				<div class="gameList" data-searchtags="arraySearchTags">
					<input type="checkbox" id="folderName" name="game">
					<label for="folderName">gameTitle</label>
				</div>
			</template>
			
			<script>
			</script>
		</form>
	</main>
	
	<footer>
		<a href="">Help us over on github!</a> <a href="">Site not working?</a> <a href="">Graphic packs for Cemu&lt;1.8.0</a>
	</footer>
</body>
</html>
