<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>Cemu Graphic Packs</title>
	<link rel="stylesheet" type="text/css" href="css/index.css">
	<link href="https://fonts.googleapis.com/css?family=Roboto:400,500" rel="stylesheet">
	<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
	<meta name="theme-color" content="#2c3e50"/>
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<!-- >>> Meta <<< -->
	<meta name="twitter:card" content="summary"/>
	<meta name="twitter:title" content="Cemu Graphic Packs"/>
	<meta name="twitter:description" content="Community Made Graphic Packs for Cemu."/>
	<meta name="application-name" content="Cemu Graphic Packs Configurator">
	<meta name="description" content="Community Made Graphic Packs for Cemu.">
	<meta name="keywords" content="Cemu, Wii U, Graphic Pack, Modification, Upscale, Games, Community">
	<!-- >>> Javascript functions <<< -->
	<script>
		// Calculate Github repository info, avoid using extra api calls.
		repositoryUsername = "Crementif"; // Replace with window.location.host.split(".")[0];
		repositoryName = "CemuGraphicPacks"; // Replace with window.location.pathname.split("/")[1];
		defaultFetchUrl = "https://api.github.com/repos/"+repositoryUsername+"/"+repositoryName+"/git/trees/master:src?recursive=3";
		defaultFileUrl = "https://raw.githubusercontent.com/"+repositoryUsername+"/"+repositoryName+"/master/src/"
		reportUrl = "https://github.com/"+repositoryUsername+"/"+repositoryName+"/issues/";
		// This info is only used to make 'dynamic' fetch calls.
		
		var gameList = {};
		var selected = false;
		function textureRule(sectionName) {
    		this.sectionName = sectionName;
			// Filters
   			this.width = null;
    		this.height = null;
    		this.formats = null;
			this.formatsExcluded = null;
			this.tilemodes = null;
			this.tilemodesExcluded = null;
			// Overwrites
			this.overwriteWidth = [undefined, 0, 0];
			this.overwriteHeight = [undefined, 0, 0];
			this.overwriteFormat = [undefined, 0, 0];
		}
		
		function generateReportIssueUrl(title, body) {
			return reportUrl+"new?title="+title+"&body="+body;
		}
		
		function addGameList(folderName, gameTitle) { // Using templates to add new game entries.
			document.getElementById("gameList").appendChild(document.importNode(document.querySelector('#gameEntryTemplate').content, true));
			
			currentGameTemplate = document.getElementById("input_folderName").parentElement;
			currentGameTemplate.getElementsByTagName("input")[0].id="input_"+folderName;
			currentGameTemplate.getElementsByTagName("input")[0].name=folderName;
			currentGameTemplate.getElementsByTagName("label")[0].htmlFor="input_"+folderName;
			currentGameTemplate.getElementsByTagName("label")[0].innerText=gameTitle[0]; // The first name tag should always be the game name.
			
			// Try to avoid name overflows by approximately calculating the length and optionally change it's listed title.
			if (document.getElementsByName("selectGames")[0].offsetWidth < currentGameTemplate.getElementsByTagName("label")[0].offsetWidth) {
				if (gameTitle.length > 0) currentGameTemplate.getElementsByTagName("label")[0].innerText=gameTitle[1]; // Always use the second name tag.
			}
		}
		
		function filterGameList(searchString) {
			searchResults = 0;
			if (searchString.value.toLowerCase().indexOf("mario od")>-1) document.getElementById("logo").innerText="SwEmu Graphic Packs"; // 'ha funny'
			for (var game in gameList) {
				for (i=0; i < gameList[game].searchTags.length; i++) {
					// Now compare it with the search string
					if (gameList[game].searchTags[i].toLowerCase().indexOf(searchString.value.toLowerCase()) > -1) {
						document.getElementsByName(game)[0].parentElement.style="";
						searchResults += 1;
						break; // Found 1 tag that matched. Quit looping this game entry.
					}
					else {
						document.getElementsByName(game)[0].parentElement.style="display: none;";
					}
				}
			}
			if (searchResults === 0) {
				// Show no search results message.
				document.getElementById("noSearchResults").style="";
				document.getElementById("searchIssueUrl").href=generateReportIssueUrl("[Missing] "+searchString.value+" graphic pack","The website couldn't resolve or find a graphic packs if I searched for '"+searchString.value+"'. This shouldn't be the case as it runs on Cemu [include screenshot link]. Maybe it just needs to be added as a search tag and could be found with some other tags. Thanks for checking!");
			}
			else {
				document.getElementById("noSearchResults").style="display: none;";
			}
		}
		
		function showLoad() {
			for (var game in gameList) {
				addGameList(game, gameList[game].searchTags);
				// console.log(gameList[game]);
			}
		}
		
		function filterUndefined(array) {
			newArray = [];
			for (i=0; i < array.length; i++) {
    			if (array[i] !== undefined) newArray.push(array[i]);
  			}
			return newArray;
		}
		
		function fetchUrl(url, options) {
			return fetch(url, options).then(function(fetchResponse) {
				if (!fetchResponse.ok) {
					throw Error("A wild fetch problem appeared! It's super effective! It's Fetch Status Codeâ„¢ is "+fetchResponse.statusText);
				}
				return fetchResponse;
			})
		}
		
		function fetchJson(jsonUrl) { // Async, returns Promise.
			return fetchUrl(jsonUrl, {cache: "force-cache", headers: {Accept: "application/vnd.github.v3+json"}}).then(jsonResponse => jsonResponse.json());
		}
		
		function fetchText(textUrl) {
			return fetchUrl(defaultFileUrl+textUrl, {cache: "no-store"}).then(textResponse => textResponse.text());
		}
		
		function listResponses(treeEntry) {
			// Process every entry passed into gameList.
			if (treeEntry.path.split("/").length - 1 == 0) { // 
				// Found game folder, add game's array to gameList.
				gameList[treeEntry.path] = {}; // Creates gameList abbtribute for this game.
				currentGame = treeEntry.path; // This allows `this` to access this game's attribute.
			}
			else if (treeEntry.path == treeEntry.path.split("/")[0]+"/rules.txt") {
				// Found main resolution pack, crawl (meta)data info.
				return fetchText(treeEntry.path).then(rulesResponse => {
					// Define some functions only used for rules.txt's.
					function getKeyProperties(keyString) {
						// Split name and value (and trim them). Returns an array, key name[0] and key value[1].
						return keyString.split(/=(.+)/).map(array => array.trim());
					}
					function processGameRule(textureRule) {
						// Save instructions to this file's entry in the game folder.
						if (textureRule.overwriteWidth[0]=="auto") {
							gameList[currentGame][treeEntry.path].push([textureRule.width, textureRule.overwriteWidth[1], textureRule.overwriteWidth[2]]);
						}
						if (textureRule.overwriteHeight[0]=="auto") {
							gameList[currentGame][treeEntry.path].push([textureRule.height, textureRule.overwriteHeight[1], textureRule.overwriteHeight[2]]);
						}
						if (textureRule.overwriteFormat[0]=="unimplemented") {
							// Implement overwriteFormat features too depending if it's necessairy in any way...
						}
					}
					
					rulesLines = rulesResponse.match(/[^\r\n]+/g);
					currentGame = treeEntry.path.split("/")[0];
					currentRule = new textureRule(undefined);
					gameList[currentGame][treeEntry.path] = [];
					indexLength = 0;
					
					for (i=0; i<rulesLines.length; i++) {
						// Keeping comments, but have something to compare with. Also make a variable that holds the current line, as it'll result in overall faster read access.
						currentLine = rulesLines[i].trim();
						parseLine = currentLine.substr(0, -currentLine.indexOf("#")>0 ? currentLine.length : currentLine.indexOf("#")).trim();
						
						if (currentLine !== "") {
							if (parseLine.charAt(0) == '[' && parseLine.slice(-1) == ']') { // New section
								// First, process the textureRule before creating a new textureRule.
								if (currentRule.sectionName!=undefined) processGameRule(currentRule);
								currentRule = new textureRule(parseLine);
							}
							else if (currentRule.sectionName=="[Definition]") {
								// Generally, we only expect metadata in "[Definition]" section for rules.
								if (currentLine.charAt(0) == '#' && currentLine.charAt(1) == '#') { // Current line
									gameList[currentGame][getKeyProperties(currentLine.substr(2))[0]] = JSON.parse(getKeyProperties(currentLine.substr(2))[1]);
								}
								// Now only expect either a name or titleId's keys.
								else if (getKeyProperties(parseLine)[0]=="name") { // Game Title
									gameList[currentGame].gameTitle = getKeyProperties(parseLine)[1].slice(1, -1); // Removes quotes.
								}
								else if (getKeyProperties(parseLine)[0]=="titleIds") { // Game IDs
									gameList[currentGame].titleIds = getKeyProperties(parseLine)[1];
								}
								else {
									console.warn("Unexpected rules line: `"+parseLine+"` in `"+currentRule.sectionName+"` section from `"+treeEntry.path+"`.");
								}
							}
							else if (currentRule.sectionName=="[TextureRedefine]") {
								// First, read the filters.
								if (getKeyProperties(parseLine)[0]=="width") {
									currentRule.width = getKeyProperties(parseLine)[1];
								}
								else if (getKeyProperties(parseLine)[0]=="height") {
									currentRule.height = getKeyProperties(parseLine)[1];
								}
								else if (getKeyProperties(parseLine)[0]=="formats") {
									currentRule.formats = getKeyProperties(parseLine)[1];
								}
								else if (getKeyProperties(parseLine)[0]=="formatsExcluded") {
									currentRule.formatsExcluded = getKeyProperties(parseLine)[1];
								}
								else if (getKeyProperties(parseLine)[0]=="tilemodes") {
									currentRule.tilemodes = getKeyProperties(parseLine)[1];
								}
								else if (getKeyProperties(parseLine)[0]=="tilemodesExcluded") {
									currentRule.tilemodesExcluded = getKeyProperties(parseLine)[1];
								}
								// Read overwrites into this format [value, index]
								else if (getKeyProperties(parseLine)[0]=="overwriteWidth") {
									currentRule.overwriteWidth = [getKeyProperties(parseLine)[1],indexLength+rulesLines[i].indexOf(getKeyProperties(parseLine)[1]), getKeyProperties(parseLine)[1].length];
								}
								else if (getKeyProperties(parseLine)[0]=="overwriteHeight") {
									currentRule.overwriteHeight = [getKeyProperties(parseLine)[1],indexLength+rulesLines[i].indexOf(getKeyProperties(parseLine)[1]), getKeyProperties(parseLine)[1].length];
								}
								else if (getKeyProperties(parseLine)[0]=="overwriteFormat") {
									currentRule.overwriteFormat = [getKeyProperties(parseLine)[1],indexLength+rulesLines[i].indexOf(getKeyProperties(parseLine)[1]), getKeyProperties(parseLine)[1].length];
								}
							}
						}
						indexLength += rulesLines[i].length;
					}
					gameList[currentGame].searchTags.unshift(gameList[currentGame].gameTitle); // Add game title to search tags, easier to pass.
					
					return rulesResponse;
				});
			}
		}
		
		function listGames(treeFetchUrl) { // Fetch repository contents
			if (self.fetch) {
				// Fetch is supported by browser.
				fetchJson(treeFetchUrl).then(treeResponse => {
					// Initialize new Promise, made out of every other game file.
					Promise.all(filterUndefined(treeResponse.tree.map(listResponses/*For every entry in the fetched github json*/))).then(dataResponses => {
						// Now that all promises are resolved (and everything is in gameList), wait for user interaction to finish.
						showLoad();
						console.log("All promises are resolved, succesfully loaded "+dataResponses.length+" responses!");
					});
				});
			}
			else {
				console.warn("Fetch isn't supported (yet) for your browser. If you get this error, your browser isn't yet supported by this website.");
			}
		}
		
		function showGame(labelClicked) {
			currentTitle = gameList[labelClicked.previousElementSibling.name];
			currentRules = currentTitle[labelClicked.previousElementSibling.name+"/rules.txt"];
			document.getElementById("GameTitle").innerText=currentTitle.gameTitle;
			document.getElementById("options").innerHTML="";
			for (i=0; i < currentRules.length; i++) {
				var para = document.createElement("p");
				var node = document.createTextNode("Texture rule with res: "+currentRules[i][0]+", which index is "+currentRules[i][1]+" with a length of "+currentRules[i][2]+".");
				
				para.appendChild(node);
				document.getElementById("options").appendChild(para);
			}
			document.getElementById("settingsSection").className="maximized";
		}
		
		function continueToSettings() {
			if (selected) {
				console.debug("Going to the graphic pack settings...");
				document.getElementById("continueButton").value="Go back";
				document.getElementById("actionTitle").innerText="Select a game to view it's options.";
				// Go to the next stage
				for (i=0; i<document.getElementsByClassName("checkbox").length; i++) {
					if (!document.getElementsByClassName("checkbox")[i].checked) {
						document.getElementsByClassName("checkbox")[i].parentElement.style="display: none;";
					}
					else if (document.getElementsByClassName("checkbox")[i].checked) {
						document.getElementsByClassName("checkbox")[i].nextElementSibling.onclick=function() {showGame(this)};

					}
					document.getElementsByClassName("checkbox")[i].style="display: none;";
				}
			}
		}
		function hoverAction(hovering) {
			if (hovering) {
				for (var i=0; i < document.getElementsByClassName("checkbox").length; i++) {
					if (document.getElementsByClassName("checkbox")[i].checked) {
						document.getElementById("continueButton").style="background-color: rgba(158,158,158,.3);";
						selected = true;
						return true;
					}
				}
			}
			selected = false;
			document.getElementById("continueButton").style="background-color: rgba(158,158,158,.2);";
			return false;
		}
		
		function changePreviewSize() {
			if (document.getElementById("options").scrollTop > 10) {
				document.getElementById("settingsSection").className="minimized";
			}
			else {
				document.getElementById("settingsSection").className="maximized";
			}
		}
		
		listGames(defaultFetchUrl);
	</script>
	<!-- <<< End Javascript >>> -->
</head>
<body>
	<header>
		<a id="logo" href="/index.html">Cemu Graphic Packs</a>
		<nav>
			<ul class="progressBar">
				<li><a id="progressBar1" href="#">Select games</a></li>
				<li><a id="progressBar2" href="#">Select your Graphic Pack Settings</a></li>
			</ul>
		</nav>
	</header>
	
	<main>
		<form name="selectGames">
			<p id="actionTitle">Select the games you want to be improved<br></p>
			<input type="search" id="searchGames" placeholder="Search games..." oninput="filterGameList(this)">
			
			<div id="gameList">
				<template id="gameEntryTemplate">
					<div class="gameEntry">
						<input type="checkbox" id="input_folderName" name="folderName" class="checkbox">
						<label for="input_folderName">gameTitle</label>
					</div>
				</template>
			</div>
			
			<p id="noSearchResults" style="display: none;">
				<strong>No such thing could be found.</strong><br> Make sure you typed it correctly. Are you sure that it's both a native Wii U title and that it runs on Cemu?<br><br> If you're sure that it runs and this repository doesn't have <strong>any</strong> graphic pack for it, you can <a href="" id="searchIssueUrl">create a Github Issue</a> about it here and kindly ask someone. You can also <a href="https://github.com/slashiee/cemu_graphic_packs/wiki/How-to-create-Graphic-Packs">make your own graphic pack</a> with the help of the guide.
			</p>
			
			<input type="button" class="button" id="continueButton" value="Continue" onMouseOver="hoverAction(true);" onMouseOut="hoverAction(false);" onClick="continueToSettings();"/>
		</form>
		<div id="settingsSection">
			<h2 id="GameTitle">Game Title here.</h2>
			<div id="preview">
			</div>
			<div id="options" onScroll="changePreviewSize();">
			</div>
			<input type="button" class="button" id="nextButton" value="Next Game" onClick="nextGame();"/>
		</div>
	</main>
	<div id="localstorageWarning">
		This site uses localstorage for storing previous selections and other features. Do you want store your choices? You can change this choice in the settings.
		<span>
			<strong onClick="localStorage.setItem('localstoragePref', 'true'); document.getElementById('localstorageWarning').style='display: none';">Sure</strong>
			<strong onClick="localStorage.setItem('localstoragePref', 'false'); document.getElementById('localstorageWarning').style='display: none';">Nope</strong>
		</span>
		<script>
			if (typeof localStorage.getItem("localstoragePref")==="string" || navigator.doNotTrack==="1") {
				document.getElementById("localstorageWarning").style="display: none;";
			}
		</script>
	</div>
	<footer>
		<strong>Settings</strong>
		<span>
			<a href="">Help us over on github!</a>
			<a href="">Site not working?</a>
			<a href="">Graphic packs for Cemu&lt;1.8.0</a>
		</span>
	</footer>
</body>
</html>